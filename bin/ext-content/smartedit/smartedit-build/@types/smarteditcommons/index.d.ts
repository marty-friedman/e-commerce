import * as angular from 'angular';
declare module 'smarteditcommons' {
// ******************************************************* 
// This file is automatically generated 
// Do not modify this file -- YOUR CHANGES WILL BE ERASED! 
// ******************************************************* 


/// <reference types="angular" />

/**
 * @ngdoc directive
 * @name yMoreTextModule.component:yMoreTextComponent
 * @element more-text
 * @description
 * The component for truncating strings and adding an ellipsis.
 * If the limit is less then the string length then the string is truncated and 'more'/'less' buttons
 * are displayed to expand or collapse the string.
 *
 * @param {< String} text the text to be displayed
 * @param {< String =} limit index in text to truncate to. Default value is 100.
 * @param {< String =} moreLabelI18nKey the label property value for a more button. Default value is 'more'.
 * @param {< String =} lessLabelI18nKey the label property value for a less button. Default value is 'less'.
 * @param {< String =} ellipsis the ellipsis for a truncated text. Default value is an empty string.
 */
export const yMoreTextComponent: angular.IComponentOptions;

/// <reference types="angular" />
/// <reference types="angular-resource" />

/**
 * @ngdoc overview
 * @name yMoreTextModule
 *
 * @description
 * Module containing parts of the yMoreTextComponent component.
 */
export const yMoreTextModule: angular.IModule;

/// <reference types="lodash" />


export type Cloneable = Primitive | Primitive[] | Payload;
/**
 * @ngdoc service
 * @name functionsModule.service:CloneableUtils
 *
 * @description
 * utility service around Cloneable objects
 */
export class CloneableUtils {
    
    constructor(lodash: lo.LoDashStatic);
    /**
     * @ngdoc method
     * @name functionsModule.service:CloneableUtils#makeCloneable
     * @methodOf functionsModule.service:CloneableUtils
     * @description
     * returns a "cloneable" version of an object.
     * Something is cloneable when it can be sent through W3C postMessage.
     * To this purpose, functions must be removed from the cloneable candidate.
     * @param {Object} json the object to be made cloneable
     * @returns {Cloneable} the cloneable copy of the object
     */
    makeCloneable(_json: any): Cloneable;
    
}












export interface Page<T> {
    pagination: Pagination;
    results: T[];
    [index: string]: T[] | Pagination;
}


export interface Pageable extends Payload {
    currentPage: number;
    mask?: string;
    pageSize?: number;
    sort?: string;
}

export interface Pagination {
    totalCount: number;
}


export class Payload {
    [index: string]: Primitive | Primitive[] | Payload | Payload[];
}

export type Primitive = string | number | boolean;


export interface TypedMap<T> {
    [index: string]: T;
}

export * from './dtos';
export * from './services';
export * from './components';
export * from './utils';


export type MethodAnnotation = (target: any, propertyName: string, originalMethod: (...x: any[]) => any, ...invocationArguments: any[]) => any;
export type MethodAnnotationFactory = (...x: any[]) => MethodAnnotation;
export class AnnotationService {
    
    setMethodAnnotationFactory(name: string, annotationFactory: MethodAnnotationFactory): MethodAnnotationFactory;
    getMethodAnnotationFactory(name: string): (...factoryArgument: any[]) => (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(...x: any[]) => any>) => void;
}
export const annotationService: AnnotationService;
/**
 * exposes to the smarteditcommons namespace that is declared as "external" in downstream extensions
 */
export function addAsExternal<T>(annotationName: string, annotationFunction: T): T;

export const cache: (...factoryArgument: any[]) => (target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(...x: any[]) => any>) => void;

export interface IDragAndDropEvents {
    TRACK_MOUSE_POSITION: string;
    DROP_ELEMENT: string;
    DRAG_DROP_START: string;
    DRAG_DROP_END: string;
    DRAG_DROP_CROSS_ORIGIN_START: string;
}
/**
 * @ngdoc object
 * @name smarteditServicesModule.object:IMousePosition
 * @description
 * Pointer coordinates
 */
export interface IMousePosition {
    /**
     * @ngdoc property
     * @name x
     * @propertyOf smarteditServicesModule.object:IMousePosition
     * @description
     * abscissa of the pointer position
     */
    x: number;
    /**
     * @ngdoc property
     * @name y
     * @propertyOf smarteditServicesModule.object:IMousePosition
     * @description
     * ordinate of the pointer position
     */
    y: number;
}
export type IDragEventType = 'drop' | 'dragenter' | 'dragover' | 'dragleave';
export const IDragEventType: {
    DROP: IDragEventType;
    DRAG_ENTER: IDragEventType;
    DRAG_OVER: IDragEventType;
    DRAG_LEAVE: IDragEventType;
};
export interface IDragAndDropScrollingService {
    toggleThrottling(isEnabled: boolean): void;
}

export * from './IDragAndDropScrollingService';
export * from './InViewElementObserver';

/// <reference types="angular" />
/// <reference types="angular-mocks" />
/// <reference types="lodash" />



export interface QueueElement {
    component: HTMLElement;
    isIntersecting: boolean;
}
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:InViewElementObserver
 * @description
 * InViewElementObserver maintains a collection of eligible DOM elements considered "in view".
 * <br/>An element is considered eligible if matches at least one of the selectors passed to the service.
 * <br/>An eligible element is in view when and only when it intersects with the view port of the window frame.
 * <br/>This services provides as well convenience methods around "in view" components:
 */
/** @ngInject */
export class InViewElementObserver {
    
    
    
    
    
    
    
    
    
    
    
    
    constructor($log: angular.ILogService, $document: angular.IDocumentService, compareHTMLElementsPosition: () => (node1: HTMLElement, node2: HTMLElement) => number, lodash: lo.LoDashStatic, yjQuery: JQueryStatic, isBlank: any, isPointOverElement: (mousePosition: IMousePosition, component: HTMLElement) => boolean, testModeService: TestModeService);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:InViewElementObserver#elementFromPoint
     * @methodOf smarteditServicesModule.service:InViewElementObserver
     * @description
     * Retrieves the element targeted by the given mousePosition.
     * <br/>On some browsers, the native Javascript API will not work when targeting
     * an element inside an iframe from the container if a container overlay blocks it.
     * <br/>In such case we resort to returning the targeted element amongst the list of "in view" elements
     * @param {IMousePosition} mousePosition the fixed {@link smarteditServicesModule.object:IMousePosition coordinates} of the pointer
     */
    elementFromPoint(mousePosition: IMousePosition): Element;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:InViewElementObserver#addSelector
     * @methodOf smarteditServicesModule.service:InViewElementObserver
     * @description
     * Declares a new jQuery selector in order to observe more elements.
     * @param {string[]} selector a {@link https://jquery.com jQuery} selector
     */
    addSelector(selector: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:InViewElementObserver#getAllElements
     * @methodOf smarteditServicesModule.service:InViewElementObserver
     * @description
     * Retrieves the full list of eligible DOM elements even if they are not "in view".
     * @return {Element[]} An array of DOM elements
     */
    getAllElements(): Element[];
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:InViewElementObserver#getInViewElements
     * @methodOf smarteditServicesModule.service:InViewElementObserver
     * @description
     * Retrieves the list of currently "in view" DOM elements.
     * @return {Element[]} An array of DOM elements
     */
    getInViewElements(): Element[];
    
    
    
    
    
    
    
    
    
    
    
    
    
    
}

/**
 * We are doing forced 
 * If we don't include the below 
 * There is an open issue in typescript github regarding forced 
 * https://github.com/Microsoft/TypeScript/issues/9191
 * https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-
 *
 * If an interface X extends an interface Y, make sure X has all types it needs from Y by checking index.d.ts, if not, do force 
 */




















/// <reference types="angular" />
export interface ICatalog {
    name: string;
    uuid?: string;
}
export interface ICatalogService {
    /**
     * list catalogs for a given site
     *
     * @param {=string} siteId the site identifier
     *
     * @return {ng.IPromise<ICatalog[]>} list of catalogs for the given site
     */
    getCatalogs(siteId?: string): ng.IPromise<ICatalog[]>;
}

/// <reference types="angular" />


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IContextualMenuButton
 * @description
 * payload passed to ContextualMenuService#addItems, to describe a contextual menu button
 */
export interface IContextualMenuButton extends IFeature, IPrioritized {
    /**
     * @ngdoc object
     * @name smarteditServicesModule.object:action
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {Object} action The action to be performed when clicking the menu item.
     * Action is an object that must contain exactly one of callback | callbacks | template | templateUrl<br />
     */
    action?: {
        /**
         * @ngdoc property
         * @name smarteditServicesModule.property:template
         * @propertyOf smarteditServicesModule.object:action
         * @description {string} template is an html string that will displayed below the menu item when the item is clicked.
         */
        template?: string;
        /**
         * @ngdoc property
         * @name smarteditServicesModule.property:templateUrl
         * @propertyOf smarteditServicesModule.object:action
         * @description {string} templateUrl is the same as template but instead of passing a string, pass a url to an html file.
         */
        templateUrl?: string;
        /**
         * @ngdoc property
         * @name smarteditServicesModule.property:callbacks
         * @propertyOf smarteditServicesModule.object:action
         * @description {object} map of DOM events occuring on the contextual menu button and callbacks to be invoked when they occur
         */
        callbacks?: TypedMap<(configuration?: IContextualMenuConfiguration, $event?: Event) => void>;
        /**
         * @ngdoc method
         * @name callback
         * @methodOf smarteditServicesModule.object:action
         * @description {Function} callback A function executed on clicking of the menu item. It is invoked with the component specific {@link IContextualMenuConfiguration IContextualMenuConfiguration}
         * @param {IContextualMenuConfiguration=} configuration the smartedit component specific {@link smarteditServicesModule.interface:IContextualMenuConfiguration IContextualMenuConfiguration}
         * @param {$event=} $event the jQuery event triggering the callback
         */
        callback?(configuration?: IContextualMenuConfiguration, $event?: Event): void;
    };
    /**
     * @ngdoc property
     * @name i18nKey
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} i18nKey i18nKey Is the message key of the contextual menu item to be translated.
     */
    i18nKey?: string;
    /**
     * @ngdoc property
     * @name displayClass
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} displayClass Contains the CSS classes used to style the contextual menu item
     */
    displayClass?: string;
    /**
     * @ngdoc property
     * @name displayIconClass
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} displayIconClass Contains the CSS classes used to style the non-idle icon of the contextual menu item to be displayed.
     */
    displayIconClass?: string;
    /**
     * @ngdoc property
     * @name displaySmallIconClass
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} displaySmallIconClass displaySmallIconClass Contains the location of the smaller version of the icon to be displayed when the menu item is part of the More... menu options.
     */
    displaySmallIconClass?: string;
    /**
     * @ngdoc property
     * @name iconIdle
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} iconIdle iconIdle Contains the location of the idle icon of the contextual menu item to be displayed.
     */
    iconIdle?: string;
    /**
     * @ngdoc property
     * @name iconNonIdle
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String=} iconNonIdle iconNonIdle Contains the location of the non-idle icon of the contextual menu item to be displayed.
     */
    iconNonIdle?: string;
    /**
     * @ngdoc property
     * @name templateUrl
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description
     * deprecated since 6.5, see {@link smarteditServicesModule.object:action action}
     * @deprecated since 6.5, see {@link smarteditServicesModule.object:action action}
     */
    templateUrl?: string;
    /**
     * @ngdoc property
     * @name regexpKeys
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {String} regexpKeys array of regular expressions matching component types eligible for this button
     */
    regexpKeys: string[];
    /**
     * @ngdoc property
     * @name callbacks
     * @propertyOf smarteditServicesModule.interface:IContextualMenuButton
     * @description
     * deprecated since 6.7, see {@link smarteditServicesModule.object:action action}
     * @deprecated since 6.7, see {@link smarteditServicesModule.object:action action}
     */
    callbacks?: TypedMap<(configuration?: IContextualMenuConfiguration, $event?: Event) => void>;
    /**
     * @ngdoc method
     * @name condition
     * @methodOf smarteditServicesModule.interface:IContextualMenuButton
     * @description {Function} contextualMenuItemsMap.condition condition Is an optional entry that holds the condition function required to activate the menu item. It is invoked with a {@link smarteditServicesModule.interface:IContextualMenuConfiguration IContextualMenuConfiguration} payload
     */
    condition?(configuration: IContextualMenuConfiguration): boolean | angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name callback
     * @methodOf smarteditServicesModule.interface:IContextualMenuButton
     * @description
     * deprecated since 6.7, see {@link smarteditServicesModule.object:action action}
     * @deprecated since 6.7, see {@link smarteditServicesModule.object:action action}
     */
    callback?(configuration?: IContextualMenuConfiguration, $event?: Event): void;
}

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IContextualMenuConfiguration
 * @description
 * The smartedit component specific configuration being passed to contextualMenuService
 * to retrieve the appropriate list of {@link smarteditServicesModule.interface:IContextualMenuButton IContextualMenuButton}
 * and being passed to condition and callbak function of {@link smarteditServicesModule.interface:IContextualMenuButton IContextualMenuButton}
 */
export interface ComponentAttributes {
    [index: string]: string;
    smarteditCatalogVersionUuid: string;
    smarteditComponentId: string;
    smarteditComponentType: string;
    smarteditComponentUuid: string;
    smarteditElementUuid: string;
}
export interface IContextualMenuConfiguration {
    /**
     * @param {Map<ComponentAttributes>} componentAttributes the map of all attributes prefixed with smartedit- collected on the DOM element
     */
    componentAttributes: ComponentAttributes;
    /**
     * @param {String} componentType The type code of the selected component.
     */
    componentType: string;
    /**
     * @param {String} componentId The ID of the selected component.
     */
    componentId: string;
    /**
     * containerType The type code of the container of the component if applicable, this is optional.
     */
    containerType?: string;
    /**
     * @param {String} containerId The ID of the container of the component if applicable, this is optional.
     */
    containerId?: string;
    /**
     * @param {String} slotId the smarteditComponent id of the slot containing the component, null if a slot itself
     */
    slotId: string;
    /**
     * @param {String} slotUuid the UUID id of the slot containing the component, null if a slot itself
     */
    slotUuid: string;
    /**
     * @param {Number} iLeftBtns The number of visible contextual menu items for a specified component.
     */
    iLeftBtns: number;
    /**
     * @param {number} element The DOM element of selected component
     */
    element: HTMLElement;
    /**
     * @param {boolean} isComponentHidden hiiden state of the component
     */
    isComponentHidden: boolean;
}

/// <reference types="angular" />

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IDecorator
 *
 * @description
 * Interface for IDecorator and it acts as a payload passed to addDecorator method of featureService method to register a decorator as a feature.
 */
export interface IDecorator extends IFeature {
    displayCondition?(componentType: string, componentId: string): ng.IPromise<boolean>;
}

export interface InternalFeature {
    /**
     * @ngdoc property
     * @name key
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The feature (could be IDecorator | IToolbarItem | IContextualMenuButton) key defined in the API
     */
    key: string;
    /**
     * @ngdoc property
     * @name nameI18nKey
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The i18n key that stores the feature name to be translated.
     */
    nameI18nKey: string;
    /**
     * @ngdoc property
     * @name descriptionI18nKey
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The i18n key that stores the feature description to be translated. The description is used as a tooltip in the web application. This is an optional parameter.
     */
    descriptionI18nKey?: string;
    /**
     * @ngdoc property
     * @name permissions
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The list of permissions required to enable the feature.
     */
    permissions?: string[];
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IFeature
 *
 * @description
 * IFeature - Interface for feature configuration DTO in FeatureService
 */
export interface IFeature extends InternalFeature {
    /**
     * @ngdoc property
     * @name enablingCallback
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The callback to be called when feature is enabled.
     */
    enablingCallback?: () => void;
    /**
     * @ngdoc property
     * @name disablingCallback
     * @propertyOf smarteditServicesModule.interface:IFeature
     * @description The callback to be called when feature is disbled.
     */
    disablingCallback?: () => void;
}

/// <reference types="lodash" />
/// <reference types="angular" />


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IFeatureService
 *
 * @description
 * The interface stipulates how to register features in the SmartEdit application and the SmartEdit container.
 * The SmartEdit implementation stores two instances of the interface across the {@link gatewayFactoryModule.gatewayFactory gateway}: one for the SmartEdit application and one for the SmartEdit container.
 */
export class IFeatureService implements IProxiedService {
    
    
    
    readonly gatewayId: string;
    constructor(lodash: lo.LoDashStatic, cloneableUtils: CloneableUtils);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#register
     * @methodOf smarteditServicesModule.interface:IFeatureService
     * @description
     * This method registers a feature.
     * When an end user selects a perspective, all the features that are bound to the perspective
     * will be enabled when their respective enablingCallback functions are invoked
     * and all the features that are not bound to the perspective will be disabled when their respective disablingCallback functions are invoked.
     * The SmartEdit application and the SmartEdit container hold/store an instance of the implementation because callbacks cannot cross the gateway as they are functions.
     *
     * this method is meant to register a feature (identified by a key).
     * When a perspective (registered through {@link smarteditServicesModule.interface:IPerspectiveService#methods_register IPerspectiveService.register}) is selected, all its bound features will be enabled by invocation of their respective enablingCallback functions
     * and any feature not bound to it will be disabled by invocation of its disablingCallback function.
     * Both SmartEdit and SmartEditContainer will hold a concrete implementation since Callbacks, being functions, cannot cross the gateway.
     * The function will keep a frame bound reference on a full feature in order to be able to invoke its callbacks when needed.
     *
     * @param {IContextualMenuButton | IDecorator | IToolbarItem} configuration of a {@link smarteditServicesModule.interface:IContextualMenuButton IContextualMenuButton} or
     * {@link smarteditServicesModule.interface:IDecorator IDecorator} or {@link smarteditServicesModule.interface:IToolbarItem IToolbarItem}
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    register(configuration: IFeature): angular.IPromise<void>;
    enable(key: string): void;
    disable(key: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#getFeatureProperty
     * @methodOf smarteditServicesModule.interface:IFeatureService
     * @description
     * Returns a feature property
     *
     * @param {String} featureKey the key property value of the feature
     * @param {String} propertyName name of the property
     *
     * @return {angular.IPromise<string | string[] | (() => void)>} returns promise of property value or null if property does not exist
     */
    getFeatureProperty(featureKey: string, propertyName: keyof IFeature): angular.IPromise<string | string[] | (() => void)>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#addToolbarItem
     * @methodOf smarteditServicesModule.interface:IFeatureService
     *
     * @description
     * This method registers toolbar items as features. It is a wrapper around {@link smarteditServicesModule.interface:IFeatureService#methods_register register}.
     *
     * @param {IToolbarItem} configuration The {@link smarteditServicesModule.interface:IToolbarItem configuration} that represents the toolbar action item to be registered.
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    addToolbarItem(toolbar: IToolbarItem): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#addDecorator
     * @methodOf smarteditServicesModule.interface:IFeatureService
     *
     * @description
     * this method registers decorator and delegates to the
     *  {@link decoratorServiceModule.service:decoratorService#methods_enable enable}
     *  {@link decoratorServiceModule.service:decoratorService#methods_disable disable} methods of
     *  {@link decoratorServiceModule.service:decoratorService decoratorService}.
     * This method is not a wrapper around {@link decoratorServiceModule.service:decoratorService#addMappings decoratorService.addMappings}:
     * From a feature stand point, we deal with decorators, not their mappings to SmartEdit components.
     * We still need to have a separate invocation of {@link decoratorServiceModule.service:decoratorService#addMappings decoratorService.addMappings}
     * @param {IDecorator} configuration The {@link smarteditServicesModule.interface:IDecorator configuration} that represents the decorator to be registered.
     * @return {angular.IPromise<void>} An empty promise
     */
    addDecorator(decorator: IDecorator): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IFeatureService#addContextualMenuButton
     * @methodOf smarteditServicesModule.interface:IFeatureService
     *
     * @description
     * This method registers contextual menu buttons. It is a wrapper around {@link smarteditServicesModule.ContextualMenuService#methods_addItems contextualMenuService.addItems}.
     *
     * @param {IContextualMenuButton} btn The {@link smarteditServicesModule.interface:IContextualMenuButton btn} that represents the feature to be registered.
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    addContextualMenuButton(btn: IContextualMenuButton): angular.IPromise<void>;
    
    
    /**
     * This method registers a feature, identified by a unique key, across the {@link gatewayFactoryModule.gatewayFactory gateway}.
     * It is a simplified version of the register method, from which callbacks have been removed.
     */
    
    
}



































export * from './dragAndDrop';

/// <reference types="angular" />
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface: IBound
 * @description
 * Interface for mouse bounds
 */
export interface IBound {
    x: number;
    y: number;
    width: number;
    height: number;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:INotificationMouseLeaveDetectionService
 *
 * @description
 * The interface defines the methods required to detect when the mouse leaves the notification panel
 * in the SmartEdit application and in the SmartEdit container.
 *
 * It is solely meant to be used with the notificationService.
 */
export class INotificationMouseLeaveDetectionService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationMouseLeaveDetectionService#startDetection
     * @methodOf smarteditServicesModule.interface:INotificationMouseLeaveDetectionService
     *
     * @description
     * This method starts tracking the movement of the mouse pointer in order to detect when it
     * leaves the notification panel.
     *
     * The innerBounds parameter is considered optional. If it is not provided, it will not be
     * validated and detection will only be started in the SmartEdit container.
     *
     * Here is an example of a bounds object:
     *
     * {
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 50
     * }
     *
     * This method will throw an error if:
     *     - the bounds parameter is not provided
     *     - a bounds object does not contain the X coordinate
     *     - a bounds object does not contain the Y coordinate
     *     - a bounds object does not contain the width dimension
     *     - a bounds object does not contain the height dimension
     */
    startDetection(outerBounds: IBound, innerBounds: IBound, callback: () => any): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationMouseLeaveDetectionService#stopDetection
     * @methodOf smarteditServicesModule.interface:INotificationMouseLeaveDetectionService
     *
     * @description
     * This method stops tracking the movement of the mouse pointer.
     */
    stopDetection(): angular.IPromise<void>;
    /**
     * This method is used to start tracking the movement of the mouse pointer within the iFrame.
     */
    
    /**
     * This method is used to stop tracking the movement of the mouse pointer within the iFrame.
     */
    
    /**
     * This method is used to call the callback function when it is detected from within the iFrame that
     * the mouse left the notification panel
     */
    
    /**
     * This method is called for each mouse movement. It evaluates whether or not the
     * mouse pointer is in the notification panel. If it isn't, it calls the onMouseLeave.
     */
    
    /**
     * This method gets bounds
     */
    
    /**
     * This method gets callback
     */
    
    /**
     * This method is triggered when the service has detected that the mouse left the
     * notification panel. It will execute the callback function and stop detection.
     */
    
}

/// <reference types="angular" />

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IConfiguration
 *
 * @description
 * Interface for Notification Configuration
 */
export interface IConfiguration {
    /**
     * @ngdoc property
     * @name id
     * @propertyOf smarteditServicesModule.interface:IConfiguration
     * @description The notification's unique identifier
     */
    id: string;
    /**
     * @ngdoc property
     * @name template
     * @propertyOf smarteditServicesModule.interface:IConfiguration
     * @description The notification's HTML template. Either template or templateUrl should be present but not both.
     */
    template?: string;
    /**
     * @ngdoc property
     * @name template
     * @propertyOf smarteditServicesModule.interface:IConfiguration
     * @description The notification's template URL. Either template or templateUrl should be present but not both.
     */
    templateUrl?: string;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:INotificationService
 *
 * @description
 * INotificationService provides a service to display visual cues to inform
 * the user of the state of the application in the container or the iFramed application.
 * The interface defines the methods required to manage notifications that are to be displayed to the user.
 */
export class INotificationService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationService#pushNotification
     * @methodOf smarteditServicesModule.interface:INotificationService
     *
     * @description
     * This method creates a new notification based on the given configuration and
     * adds it to the top of the list.
     *
     * The configuration must contain either a template or template URL, but not both.
     *
     * @param {Object} configuration The notification's configuration {@link smarteditServicesModule.interface:IConfiguration IConfiguration}
     *
     * @throws An error if no configuration is given.
     * @throws An error if the configuration does not contain a unique identifier.
     * @throws An error if the configuration's unique identifier is an empty string.
     * @throws An error if the configuration does not contain a template or templateUrl.
     * @throws An error if the configuration contains both a template and template Url.
     */
    pushNotification(configuration: IConfiguration): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationService#removeNotification
     * @methodOf smarteditServicesModule.interface:INotificationService
     *
     * @description
     * This method removes the notification with the given ID from the list.
     *
     * @param {String} notificationId The notification's unique identifier.
     */
    removeNotification(notificationId: string): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:INotificationService#removeAllNotifications
     * @methodOf smarteditServicesModule.interface:INotificationService
     *
     * @description
     * This method removes all notifications.
     */
    removeAllNotifications(): angular.IPromise<void>;
}


export const instrument: ($provide: any, readObjectStructure: (arg: Cloneable) => Cloneable, TOP_LEVEL_MODULE_NAME: string) => void;

/// <reference types="angular" />


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IPageInfoService
 *
 * @description
 * The IPageInfoService provides information about the storefront page currently loaded in the iFrame.
 */
export class IPageInfoService implements IProxiedService {
    readonly gatewayId: string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPageInfoService#getPageUID
     * @methodOf smarteditServicesModule.interface:IPageInfoService
     *
     * @description
     * This extracts the pageUID of the storefront page loaded in the smartedit iframe.
     *
     * @return {angular.IPromise<string>} A promise resolving to a string matching the page's ID
     */
    getPageUID(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPageInfoService#getPageUUID
     * @methodOf smarteditServicesModule.interface:IPageInfoService
     *
     * @description
     * This extracts the pageUUID of the storefront page loaded in the smartedit iframe.
     * The UUID is different from the UID in that it is an encoding of uid and catalog version combined
     *
     * @return {angular.IPromise<string>} A promise resolving to the page's UUID
     */
    getPageUUID(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPageInfoService#getCatalogVersionUUIDFromPage
     * @methodOf smarteditServicesModule.interface:IPageInfoService
     *
     * @description
     * This extracts the catalogVersionUUID of the storefront page loaded in the smartedit iframe.
     * The UUID is different from the UID in that it is an encoding of uid and catalog version combined
     *
     * @return {angular.IPromise<string>} A promise resolving to the page's UUID
     */
    getCatalogVersionUUIDFromPage(): angular.IPromise<string>;
}

/// <reference types="angular" />




/**
 * @name smarteditServicesModule.interface:IPreviewService
 *
 * @description
 *
 * Interface for previewService.
 *
 * This service is for managing the storefront preview ticket and is proxied across the gateway. (implements)
 *
 */
export class IPreviewService implements IProxiedService {
    
    
    constructor(urlUtils: UrlUtils);
    readonly gatewayId: string;
    /**
     * @name smarteditServicesModule.interface:IPreviewService#createPreview
     * @methodOf smarteditServicesModule.interface:IPreviewService
     *
     * @description
     * This method will create a new previewTicket for the given experience, using the preview API
     * <br />
     * This method does *NOT* update the current experience.
     *
     * @param {Object} previewData Data representing storefront preview
     *
     * @returns {Object} A {@link smarteditServicesModule.interface:IPreview IPreviewResponse} object
     */
    createPreview(previewData: IPreviewData): angular.IPromise<IPreviewResponse>;
    /**
     * @name smarteditServicesModule.interface:IPreviewService#getResourcePathFromPreviewUrl
     * @methodOf smarteditServicesModule.interface:IPreviewService
     *
     * @description
     * This method will preduce a resourcePath from a given preview url
     * <br />
     * This method does *NOT* update the current experience.
     *
     * @param {Object} previewUrl A URL for a storefornt with preview
     *
     * @returns {Object} A {@link smarteditServicesModule.interface:IPreview IPreviewResponse} object
     */
    getResourcePathFromPreviewUrl(previewUrl: string): angular.IPromise<string>;
    /**
     * @name smarteditServicesModule.interface:IPreviewService#updateUrlWithNewPreviewTicketId
     * @methodOf smarteditServicesModule.interface:IPreviewService
     *
     * @description
     * This method will create a new preview ticket, and return the given url with an updated previewTicketId query param
     * <br />
     * This method does *NOT* update the current experience.
     *
     * @param {string} storefrontUrl Existing storefront url
     * @param {Object} previewData JSON representing storefront previewData (catalog, catalaog vesion, etc...)
     *
     * @returns {string} A new string with storefrontUrl having the new ticket ID inside
     */
    updateUrlWithNewPreviewTicketId(storefrontUrl: string, previewData: IPreviewData): angular.IPromise<string>;
}

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IPrioritized
 * @description
 * Interface of entities aimed at being sorted by priority
 */
export interface IPrioritized {
    /**
     * @ngdoc method
     * @name number
     * @methodOf smarteditServicesModule.interface:IPrioritized
     * @description priority an optional number ranging from 0 to 1000 used for sorting
     */
    priority?: number;
}

/// <reference types="angular" />

export interface IReflectable<T> {
    setMethod?(name: string, methodInstance: (...params: any[]) => (angular.IPromise<void | T> | angular.IPromise<T[]>)): void;
    getMethodForVoid?(name: string): (...params: any[]) => angular.IPromise<void>;
    getMethodForSingleInstance?(name: string): (...params: any[]) => angular.IPromise<T>;
    getMethodForArray?(name: string): (...params: any[]) => angular.IPromise<T[]>;
}

/// <reference types="angular" />


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IRestService
 *
 * @description
 * Common interface of smartedit REST services generated by calls to {@link smarteditServicesModule.interface:restServiceFactory restServiceFactory#get<T>}
 * IRestService<T> has strongly typed methods in both signature and return type
 * When used in the smartedit application (as opposed to smarteditContainer) calls are proxied to the smarteditContainer
 * in order to prevent cross-origin issues in the case where smartEdit and the embedded storefront are in different domains.
 */
export interface IRestService<T> extends IReflectable<T> {
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#getById
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Loads a component based on its identifier.
     *
     * @param {String} identifier The value of the object identifier.
     *
     * @returns {Object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T
     */
    getById(identifier: string): angular.IPromise<T>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#get
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Loads a unique component based on its identifier that must match the specified get parameters.
     * <br/>The REST Service Factory evaluates placeholders in the URI, if any are provided, to verify if they
     * match the search parameters.
     *
     * @param {object} searchParams The object that contains the query parameters, which are then mapped to the
     * query string
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T
     */
    get(searchParams: void | Payload): angular.IPromise<T>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#query
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Loads a list of components that match the specified search parameters.
     * <br/>The REST service evaluates the placeholders in the URI, if any are provided, to verify if
     * they match the search parameters.
     *
     * @param {object} searchParams The object that contains the query parameters, which are then mapped to the
     * query string
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T[]
     */
    query(searchParams: Payload): angular.IPromise<T[]>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#page
     * @methodOf smarteditServicesModule.interface:IRestService
     * @description
     * To be called instead of {@link smarteditServicesModule.interface:IRestService#query query} when the list is wrapped by server in an object (ex: Page).
     * <br/>The service will evaluate any placeholder in the URI with matching search params.
     * @param {object} searchParams The object that contains the query parameters, which are then mapped to the
     * query string
     * @returns {object} a {@link https://docs.angularjs.org/api/ng/service/$q promise} of <Page<T>>
     */
    page(searchParams: Pageable): angular.IPromise<Page<T>>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#update
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Updates a component.  It appends the value of the identifier to the URI.
     *
     * @param {object} payload The object to be updated. <br/>The promise will be rejected if the payload does not contain the identifier.
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T
     */
    update(payload: Payload): angular.IPromise<T>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#save
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Saves a component. It appends the value of the identifier to the URI.
     *
     * @param {object} payload The object to be saved.
     * <br/>The promise will be rejected if the payload does not contain the identifier.
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of T
     * to what the server returns.
     */
    save(payload: Payload): angular.IPromise<T>;
    /**
     * @ngdoc service
     * @name smarteditServicesModule.interface:IRestService#remove
     * @methodOf smarteditServicesModule.interface:IRestService
     *
     * @description
     * Deletes a component. It appends the value of the identifier to the URI.
     *
     * @param {object} payload The object to be updated.
     * <br/>The promise will be rejected if the payload does not contain the identifier.
     *
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of void
     */
    remove(payload: Payload): angular.IPromise<void>;
}


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:restServiceFactory
 *
 * @description
 * A factory used to generate a REST service wrapper for a given resource URL, providing a means to perform HTTP
 * operations (GET, POST, etc) for the given resource.
 */
export interface IRestServiceFactory {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:restServiceFactory#get<T>
     * @methodOf smarteditServicesModule.interface:restServiceFactory
     *
     * @description
     * A factory method used to create a REST service of type {@link smarteditServicesModule.interface:IRestService IRestService<T>}
     * that points to the given resource URI.
     * The returned service wraps a $resource object. As opposed to a $resource, the REST services retrieved from the
     * restServiceFactory can only take one object argument. The object argument will automatically be split
     * into a parameter object and a payload object before they are delegated to the wrapped $resource object.
     * If the domain is set, the domain is prepended to the given URI.
     *
     * @param {String} uri The URI of the REST service to be retrieved.
     * @param {String=} identifier An optional parameter. The name of the placeholder that is appended to the end
     * of the URI if the name is not already provided as part of the URI. The default value is "identifier".
     * <pre>
     * 	if identifier is "resourceId" and uri is "resource/:resourceId/someValue", the target URI will remain the same.
     * 	if identifier is "resourceId" and uri is "resource", the target URI will be "resource/:resourceId".
     * </pre>
     *
     * @returns {IResourceService} A {@link smarteditServicesModule.interface:IResourceService IRestService} around a {@link https://docs.angularjs.org/api/ngResource/service/$resource $resource}
     */
    get<T>(uri: string, identifier?: string): IRestService<T>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:restServiceFactory#setDomain
     * @methodOf smarteditServicesModule.interface:restServiceFactory
     *
     * @description
     * When working with multiple services that reference the same domain, it is best to only specify relative
     * paths for the services and specify the context-wide domain in a separate location. The {@link
     * smarteditServicesModule.interface:restServiceFactory#get get} method of the {@link
     * smarteditServicesModule.interface:restServiceFactory restServiceFactory} will then prefix the specified service
     * URIs with the domain and a forward slash.
     *
     * @param {String} domain The context-wide domain that all URIs will be prefixed with when services are
     * created/when a service is created
     *
     * @deprecated since 6.7
     */
    setDomain?(domain: string): void;
}

/// <reference types="angular" />

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IAuthToken
 * @description
 * Interface for Auth token
 */
export interface IAuthToken {
    access_token: string;
    expires_in: number;
    refresh_token: string;
    scope: string;
    token_type: string;
}
/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IStorageService
 * @description
 * Interface for StorageService
 */
export class IStorageService implements IProxiedService {
    readonly gatewayId: string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#isInitialized
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to determine if the storage service has been initialized properly. It
     * makes sure that the smartedit-sessions cookie is available in the browser.
     *
     * @returns {Boolean} Indicates if the storage service was properly initialized.
     */
    isInitialized(): angular.IPromise<boolean>;
    /**
     * @deprecated since 6.6
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#storePrincipalIdentifier
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to store the principal's login name in storage service. Deprecated since 6.6.
     *
     * @param {String} principalUID Value associated to store principal's login.
     */
    storePrincipalIdentifier(principalUID: string): angular.IPromise<void>;
    /**
     * @deprecated since 6.6
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#removePrincipalIdentifier
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to remove the principal's UID from storage service. Deprecated since 6.6.
     *
     */
    removePrincipalIdentifier(): angular.IPromise<void>;
    /**
     * @deprecated since 6.6
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#getPrincipalIdentifier
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to retrieve the principal's login name from storage service. Deprecated since 6.6.
     *
     * @returns {String} principalNameValue principal's name associated with the key.
     */
    getPrincipalIdentifier(): angular.IPromise<string>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#storeAuthToken
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method creates and stores a new key/value entry. It associates an authentication token with a
     * URI.
     *
     * @param {String} authURI The URI that identifies the resource(s) to be authenticated with the authToken. Will be used as a key.
     * @param {String} auth The token to be used to authenticate the user in the provided URI.
     */
    storeAuthToken(authURI: string, auth: IAuthToken): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#getAuthToken
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to retrieve the authToken associated with the provided URI.
     *
     * @param {String} authURI The URI for which the associated authToken is to be retrieved.
     * @returns {String} The authToken used to authenticate the current user in the provided URI.
     */
    getAuthToken(authURI: string): angular.IPromise<IAuthToken>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#removeAuthToken
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * Removes the authToken associated with the provided URI.
     *
     * @param {String} authURI The URI for which its authToken is to be removed.
     */
    removeAuthToken(authURI: string): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#removeAllAuthTokens
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method removes all authURI/authToken key/pairs from the storage service.
     */
    removeAllAuthTokens(): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#getValueFromCookie
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * Retrieves the value stored in the cookie identified by the provided name.
     */
    getValueFromCookie(cookieName: string, isEncoded: boolean): angular.IPromise<any>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#setItem
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * This method is used to store the item.
     *
     * @param {String} key The key of the item.
     * @param {any} value The value of the item.
     */
    setItem(key: string, value: any): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IStorageService#getItem
     * @methodOf smarteditServicesModule.interface:IStorageService
     *
     * @description
     * Retrieves the value for a given key.
     *
     * @param {String} key The key of the item.
     *
     * @returns {Promise<any>} A promise that resolves to the item value.
     */
    getItem(key: string): angular.IPromise<any>;
}


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IToolbarItem
 *
 * @description
 * Interface for ToolbarItem
 */
export interface IToolbarItem extends IFeature, IPrioritized {
    /**
     * @ngdoc property
     * @name iconClassName
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description List of classes used to display icons from fonts
     */
    iconClassName?: string;
    /**
     * @ngdoc property
     * @name icons
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description A list of image URLs for the icon images to be displayed in the toolbar for the items. The images are only available for ACTION and HYBRID_ACTION toolbar items.
     */
    icons?: string[];
    /**
     * @ngdoc property
     * @name include
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The URL to the HTML template. By default, templates are available for TEMPLATE and HYBRID_ACTION toolbar items.
     */
    include?: string;
    /**
     * @ngdoc property
     * @name contextTemplate
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The template of the context to be displayed. An optional parameter.
     */
    contextTemplate?: string;
    /**
     * @ngdoc property
     * @name contextTemplateUrl
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The templateUrl that prints the context associated to the toolbar item. An optional parameter.
     */
    contextTemplateUrl?: string;
    /**
     * @ngdoc property
     * @name keepAliveOnClose
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description keepAliveOnClose keeps the dropdown content in the DOM on close. This is an optional parameter.
     */
    keepAliveOnClose?: boolean;
    /**
     * @ngdoc property
     * @name section
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description Determines the sections(left, middle or right) of the item in the toolbar.
     */
    section?: string;
    /**
     * @ngdoc property
     * @name toolbarId
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The key that uniquely identifies the toolbar that the feature is added to.
     */
    toolbarId: string;
    /**
     * @ngdoc property
     * @name type
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The type of toolbar item. The possible value are: TEMPLATE, ACTION, and HYBRID_ACTION.
     */
    type: string;
    /**
     * @ngdoc property
     * @name callback
     * @propertyOf smarteditServicesModule.interface:IToolbarItem
     * @description The callback that is triggered when the toolbar action item is clicked.
     */
    callback?: () => void;
}

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IUrlService
 *
 * @description
 * Provides an abstract extensible url service, Used to open a given URL
 * in a new browser url upon invocation.
 *
 * This class serves as an interface and should be extended, not instantiated.
 */

export class IUrlService {
    
    
    
    
    
    
    constructor(PAGE_CONTEXT_SITE_ID: string, PAGE_CONTEXT_CATALOG: string, PAGE_CONTEXT_CATALOG_VERSION: string, CONTEXT_SITE_ID: string, CONTEXT_CATALOG: string, CONTEXT_CATALOG_VERSION: string);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IUrlService#openUrlInPopup
     * @methodOf smarteditServicesModule.interface:IUrlService
     *
     * @description
     * Opens a given URL in a new browser pop up without authentication.
     *
     * @param {String} url - the URL we wish to open.
     */
    openUrlInPopup(url: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IUrlService#path
     * @methodOf smarteditServicesModule.interface:IUrlService
     *
     * @description
     * Navigates to the given path in the same browser tab.
     *
     * @param {String} path - the path we wish to navigate to.
     */
    path(path: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IUrlService#buildUriContext
     * @methodOf smarteditServicesModule.interface:IUrlService
     *
     * @description
     * Returns a uri context array populated with the given siteId, catalogId and catalogVersion information
     *
     * @param {String} siteId - site Id
     * @param {String} catalogId - catalog Id
     * @param {String} catalogVersion - catalog version
     *
     * @return {IUriContext} uri context array
     */
    buildUriContext(siteId: string, catalogId: string, catalogVersion: string): IUriContext;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IUrlService#buildPageUriContext
     * @methodOf smarteditServicesModule.interface:IUrlService
     *
     * @description
     * Returns a page uri context array populated with the given siteId, catalogId and catalogVersion information
     *
     * @param {String} siteId - site Id
     * @param {String} catalogId - catalog Id
     * @param {String} catalogVersion - catalog version
     *
     * @return {IUriContext} uri context array
     */
    buildPageUriContext(siteId: string, catalogId: string, catalogVersion: string): IUriContext;
}

/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IWaitDialogService
 *
 * @description
 * This service be used in order to display (or hide) a 'loading' overlay. The overlay should display on top of everything, preventing
 * the user from doing any action until the overlay gets hidden.
 */
export class IWaitDialogService {
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IWaitDialogService#showWaitModal
     * @methodOf smarteditServicesModule.interface:IWaitDialogService
     *
     * @description
     * This method can be called to display the loading overlay.
     *
     * @param {String} [customLoadingMessageLocalizedKey="se.wait.dialog.message"] The i18n key that corresponds to the message to be displayed.
     */
    showWaitModal(customLoadingMessageLocalizedKey: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IWaitDialogService#hideWaitModal
     * @methodOf smarteditServicesModule.interface:IWaitDialogService
     *
     * @description
     * Removes the loading overlay.
     */
    hideWaitModal(): void;
}

/// <reference types="angular" />


/**
 * @ngdoc interface
 * @name smarteditServicesModule.interface:IPerspectiveService
 *
 * @description
 * Interface for Perspective Service
 */
export class IPerspectiveService implements IProxiedService {
    readonly gatewayId: string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#register
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method registers a perspective.
     * When an end user selects a perspective in the SmartEdit web application,
     * all features bound to the perspective will be enabled when their respective enablingCallback functions are invoked
     * and all features not bound to the perspective will be disabled when their respective disablingCallback functions are invoked.
     *
     * @param {Object} configuration The perspective's configuration {@link smarteditServicesModule.interface:IPerspective IPerspective}
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    register(configuration: IPerspective): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#switchTo
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method activates a perspective identified by its key and deactivates the currently active perspective.
     * Activating a perspective consists in activating any feature that is bound to the perspective
     * or any feature that is bound to the perspective's referenced perspectives and deactivating any features
     * that are not bound to the perspective or to its referenced perspectives.
     * After the perspective is changed, the {@link seConstantsModule.object:EVENT_PERSPECTIVE_CHANGED
     * EVENT_PERSPECTIVE_CHANGED} event is published on the {@link crossFrameEventServiceModule.service:CrossFrameEventService
     * crossFrameEventService}, with no data.
     *
     * @param {String} key The key that uniquely identifies the perspective to be activated. This is the same key as the key used in the {@link smarteditServicesModule.interface:IPerspectiveService#methods_register register} method.
     * @return {angular.IPromise<void>} An empty promise
     */
    switchTo(key: string): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#hasActivePerspective
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method returns true if a perspective is selected.
     *
     * @returns {angular.IPromise<boolean>} A promise with the value of the key of the active perspective.
     */
    hasActivePerspective(): angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#selectDefault
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method switches the currently-selected perspective to the default perspective.
     * It will also disable all features for the default perspective before enabling them all back.
     * If no value has been stored in the smartedit-perspectives cookie, the value of the default perspective is se.none.
     * If a value is stored in the cookie, that value is used as the default perspective.
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    selectDefault(): angular.IPromise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#isEmptyPerspectiveActive
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method returns true if the current active perspective is the Preview mode (No active overlay).
     *
     * @returns {angular.IPromise<boolean>} A promise with the boolean flag that indicates if the current perspective is the Preview mode.
     */
    isEmptyPerspectiveActive(): angular.IPromise<boolean>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.interface:IPerspectiveService#refreshPerspective
     * @methodOf smarteditServicesModule.interface:IPerspectiveService
     *
     * @description
     * This method is used to refresh the prespective.
     * If there is an exising perspective set then it is refreshed by replaying all the features associated to the current perspective.
     * If there is no perspective set or if the perspective is not permitted then we set the default perspective.
     *
     * @return {angular.IPromise<void>} An empty promise
     */
    refreshPerspective(): angular.IPromise<void>;
}



/**
 * @ngdoc service
 * @name smarteditServicesModule.service:PriorityService
 * @description
 * The PriorityService handles arrays of {@link smarteditServicesModule.interface:IPrioritized IPrioritized} elements
 */
/** @ngInject */
export class PriorityService {
    
    constructor(encode: any);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:PriorityService#sort<T>
     * @methodOf smarteditServicesModule.service:PriorityService
     *
     * @description
     * Will sort the candidate array by ascendign or descending priority.
     * Even if the priority is not defined for a number of elements, the sorting will still be consistent over invocations
     * @param {T[]} candidate the array of @link smarteditServicesModule.interface:IPrioritized IPrioritized} elements to be sorted
     * @param {boolean=} [ascending=true] if true, candidate will be sorted by ascending priority.
     * @returns {T[]} A promise resolving to the username,
     * previously mentioned as "principalUID", associated to the
     * authenticated user.
     */
    sort<T extends IPrioritized>(candidate: T[], ascending?: boolean): T[];
}

/** @ngInject */
export class SmarteditBoostrapGateway {
    
    constructor(gatewayFactory: any);
}

/// <reference types="angular" />
/// <reference types="angular-resource" />

/**
 * @ngdoc service
 * @name smarteditServicesModule.service:TestModeService
 *
 * @description
 * Used to determine whether smartedit is running in a e2e (test) mode
 */
export class TestModeService {
    
    
    constructor($injector: angular.auto.IInjectorService);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:TestModeService#isE2EMode
     * @methodOf smarteditServicesModule.service:TestModeService
     *
     * @description
     * returns true if smartedit is running in e2e (test) mode
     *
     * @returns {Boolean} true/false
     */
    isE2EMode(): boolean;
}


/// <reference types="angular" />
/// <reference types="lodash" />



export function translateStaticFilesLoader($q: angular.IQService, lodash: lo.LoDashStatic, restServiceFactory: IRestServiceFactory): any;



/**
 * @ngdoc service
 * @name functionsModule.service:CryptographicUtils
 *
 * @description
 * utility service around Cryptographic operations.
 */
export class CryptographicUtils {
    /**
     * @ngdoc method
     * @name functionsModule.service:CryptographicUtils#sha1Hash
     * @methodOf functionsModule.service:CryptographicUtils
     *
     * @description
     * A utility function that takes an input string and provides a cryptographic SHA1 hash value.
     *
     * @param {String} data The input string to be encrypted.
     * @returns {String} the encrypted hashed result.
     */
    sha1Hash(data: string): string;
}



export * from './UrlUtils';
export * from './CryptographicUtils';

/**
 * @ngdoc service
 * @name functionsModule.service:UrlUtils
 *
 * @description
 * A collection of utility methods for manipulating URLs
 */
export class UrlUtils {
    /**
     * @ngdoc method
     * @name functionsModule.service:UrlUtils#updateUrlParameter
     * @methodOf functionsModule.service:UrlUtils
     *
     * @description
     * Updates a URL to contain the query param and value provided. If already exists then it is updated,
     * if it did not previously exist, then it will be added.
     *
     * @param {String} url The url to be updated (this param will not be modified)
     * @param {String} key The query param key
     * @param {String} value The query param value
     *
     * @returns {String} The url with updated key/value
     */
    updateUrlParameter(url: string, key: string, value: string): string;
}

}